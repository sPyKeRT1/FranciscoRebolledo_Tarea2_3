\subsubsection{Descripción de la solución}

De forma similar, pero en complejidad mucho menor al enfoque de fuerza bruta, la solución es plantear la recursividad de la función principal pero con la diferencia de guardar los casos intermedios . Construye una matriz de tamaño 
(m+1)×(n+1), donde m y n son las longitudes de las cadenas, para almacenar los costos mínimos de transformar los primeros i caracteres de una cadena en los primeros j de la otra. Inicializa los casos base para manejar transformaciones desde o hacia cadenas vacías, y luego llena la matriz evaluando las operaciones de insertar, eliminar, reemplazar y, si es posible, transponer caracteres. El costo mínimo para cada operación se calcula acumulativamente, evitando cálculos redundantes. Finalmente, el valor en la celda (m,n) de la matriz representa el costo mínimo total.

\subsubsection{Relación de recurrencia}

\begin{equation*}
    matriz[i][j] = \min \begin{cases}
    matriz[i-1][j] + \text{costo de eliminación} \\
    matriz[i][j-1] + \text{costo de inserción} \\
    matriz[i-1][j-1] + \text{costo de sustitución}  \\
    matriz[i-2][j-2] + \text{costo de transposición}
    \end{cases}
\end{equation*}


\subsubsection{Identificación de subproblemas}

los subproblemas son las distancias mínimas de edición entre todos los prefijos de las dos cadenas. Específicamente, los subproblemas corresponden a calcular la distancia mínima de edición entre los primeros i caracteres de la primera cadena y los primeros j caracteres de la segunda cadena. La solución final se obtiene calculando la distancia entre las cadenas completas, es decir, entre los primeros m caracteres de la primera cadena y los primeros n caracteres de la segunda cadena.

\subsubsection{Complejidad Temporal y Espacial}

Para obtener las complejidades con un enfoque de programación dinámica resulta relevante el largo de las 2 cadenas para el tamaño de la matriz de memoria que se creará en el proceso, en especifico m es la longitud de la primera cadena y 
n es la longitud de la segunda cadena. El algoritmo llena una matriz de dimensiones m+1 por n+1, y cada celda de la matriz se calcula en tiempo constante de forma que cada celda almacena un subproblema. Así se puede verificar que:

\begin{center}
\begin{tabular}{c|c}
\textbf{Complejidad Temporal} & \textbf{Complejidad Espacial} \\ \hline
$T(n) = O(m * n)$ & $E(n) = O(m *n))$
\end{tabular}
\end{center}

\subsubsection{Algoritmo utilizando programación dinámica}

\begin{algorithm}[H]
\DontPrintSemicolon
\KwFunction{$\textbf{Procedure}\text{ DME\_Programacion\_Dinamica}(\text{cadena1}, \text{cadena2})$}\\
    $m \gets \text{len}(\text{cadena1})$\;
    $n \gets \text{len}(\text{cadena2})$\;
    
    Crear matriz $matriz$ de tamaño $(m+1) \times (n+1)$ inicializada con ceros\;
    
    \For{$i \gets 0$ \KwTo $m$}{
        $matriz[i][0] \gets i \cdot \text{costo\_del}(\text{cadena1}[i-1])$\;
    }
    \For{$j \gets 0$ \KwTo $n$}{
        $matriz[0][j] \gets j \cdot \text{costo\_ins}(\text{cadena2}[j-1])$\;
    }
    
    \For{$i \gets 1$ \KwTo $m$}{
        \For{$j \gets 1$ \KwTo $n$}{
            \If{$\text{cadena1}[i-1] == \text{cadena2}[j-1]$}{
                $matriz[i][j] \gets matriz[i-1][j-1]$\;
            }
            \Else{
                $matriz[i][j] \gets \min\Big($ \;
                \Indp
                $matriz[i-1][j] + \text{costo\_del}(\text{cadena1}[i-1]),$ \;
                $matriz[i][j-1] + \text{costo\_ins}(\text{cadena2}[j-1]),$ \;
                $matriz[i-1][j-1] + \text{costo\_sub}(\text{cadena1}[i-1], \text{cadena2}[j-1])$ \;
                \Indm
                $\Big)$\;
            }
            
            \If{$i > 1$ \KwAnd $j > 1$ \KwAnd $\text{cadena1}[i-1] == \text{cadena2}[j-2]$ \KwAnd $\text{cadena1}[i-2] == \text{cadena2}[j-1]$}{
                $matriz[i][j] \gets \min\Big($\;
                \Indp
                $matriz[i][j],$ \;
                $matriz[i-2][j-2] + \text{costo\_trans}(\text{cadena1}[i-1], \text{cadena1}[i-2])$\;
                \Indm
                $\Big)$\;
            }
        }
    }
    \Return $matriz[m][n]$\;
\caption{DME\_Programacion\_Dinamica}
\end{algorithm}